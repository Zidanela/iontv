/*-
 * WSDL stubs for:  tvDataDelivery.wsdl
 *   Generated by:  awk
 *           Date:  Fri Jan 12 11:21:07 2007
 *        Emitter:  Objective-C
 */

#import "tvDataDelivery.h"
#import "Preferences.h"

#import <Security/Security.h>

// URL for SOAP services used to retrieve the listings
// @"http://webservices.schedulesdirect.tmsdatadirect.com/schedulesdirect/tvlistings/xtvdService
NSString *kWebServicesSDHostname = @"webservices.schedulesdirect.tmsdatadirect.com";
NSString *kWebServicesSDPath = @"/schedulesdirect/tvlistings/xtvdService";


@implementation tvDataDelivery

static CFTypeRef deserializationCallback(WSMethodInvocationRef invocation, CFXMLTreeRef msgRoot, CFXMLTreeRef  deserializeRoot, void *info)
{
  // Create a temp file path - rather than allowing the default WebServices parser to try and handle the returned
  // XML data we just write it to a file and parse it seperately later. The WebServices parser is confused anyway
  // by a lot of the XML in this file and tries to interpret things as SOAP returned variables.
  char *tmpXMLFilePath = tempnam(NULL,"recsched.");
  NSString *xmlFilePath = [[NSString alloc] initWithCString:tmpXMLFilePath];
  free(tmpXMLFilePath);
  
  // Find the <xtvd ..> portion of the input XML - that's all we need to write out
  CFDataRef dataRef = CFXMLTreeCreateXMLData(kCFAllocatorDefault, deserializeRoot);
  NSError *anXMLParserError = [NSError alloc];
  NSXMLDocument *anXMLDoc = [[NSXMLDocument alloc] initWithData:(NSData*) dataRef options:NSXMLDocumentTidyXML error:&anXMLParserError];
  [anXMLParserError release];
  CFRelease(dataRef);

  NSXMLNode *currentNode = [anXMLDoc rootElement];
  bool foundXTVD = false;
  while (currentNode && !foundXTVD)
  {
    NSString *nodeName = [currentNode name];
    if (nodeName && ([nodeName compare:@"xtvd" options:NSCaseInsensitiveSearch] == NSOrderedSame))
    {
      foundXTVD = true;
    }
    else
      currentNode = [currentNode nextNode];
  }
  
  bool success = false;
  // Write out the piece if found
  if (foundXTVD)
  {
    [currentNode detach];
    NSXMLElement *xtvdElement = [[NSXMLElement alloc] initWithName:@"xtvd"];
    NSXMLDocument *xtvdXMLDoc = [[NSXMLDocument alloc] initWithRootElement:xtvdElement];
    [xtvdXMLDoc setCharacterEncoding:@"UTF-8"];
    [xtvdXMLDoc setVersion:@"1.0"];
    [xtvdXMLDoc setRootElement:currentNode];

    success = [[NSFileManager defaultManager] createFileAtPath:xmlFilePath contents:[xtvdXMLDoc XMLData] attributes:nil];
    [xtvdXMLDoc release];
  }
  [anXMLDoc release];
  
  // If the write was successful return a dictionary with the output file path as our 'deserialized' response
  NSDictionary *returnedDict;
  if (success)
    returnedDict = [[NSDictionary alloc] initWithObjects:[NSArray arrayWithObject:xmlFilePath] forKeys:[NSArray arrayWithObject:@"xmlFilePath"]];
  else
    returnedDict = [[NSDictionary alloc] init];
    
  [xmlFilePath release];
  return returnedDict;
}

	// Return the Result object.  If it hasn't
	// been fetched yet, this will asynchronously block
- (NSDictionary*) getResultDictionary
{
	if (fResult == NULL) {
		if (fAsyncTarget != NULL) {
			fAsyncTarget = NULL;
			fAsyncSelector = NULL;
		}

                WSMethodInvocationRef invocation = [self getRef];
                CFStringRef wsGeneratedMode = CFSTR("NS-WSSYNC");

		if (fResult == NULL) {
			WSMethodInvocationScheduleWithRunLoop(invocation, [[NSRunLoop currentRunLoop] getCFRunLoop], wsGeneratedMode);

			while (fResult == NULL)
                          [[NSRunLoop currentRunLoop] runMode:(NSString *)wsGeneratedMode beforeDate:[NSDate distantFuture]];
                        
			WSMethodInvocationUnscheduleFromRunLoop(invocation, [[NSRunLoop currentRunLoop] getCFRunLoop], wsGeneratedMode);
		}
		
		if (fResult == NULL) {
			[self handleError:@"WSMethodInvocationInvoke failed in getResultDictionary" errorString:NULL errorDomain:kCFStreamErrorDomainMacOSStatus errorNumber:paramErr];
		}
                
                // Check to see if we got an unauthorized error
                CFHTTPMessageRef responseMessage = (CFHTTPMessageRef) [fResult valueForKey:(id)kWSHTTPResponseMessage];
                if (!responseMessage)
                {
                    [self handleError:@"WSMethodInvocationInvoke failed in get response message" errorString:NULL errorDomain:kCFStreamErrorDomainMacOSStatus errorNumber:paramErr];
                    return nil;
                }
                int msgCode = CFHTTPMessageGetResponseStatusCode(responseMessage);

                if (msgCode == 401)
                {
                  // We're not authorized - we need to go through a little dance to resend the request with the authorization
                  WSMethodInvocationRef authorizedInvocation = [self genCreateInvocationRef];
                  CFHTTPMessageRef authInvocationMsgRef;
                  CFURLRef theURL = CFHTTPMessageCopyRequestURL(responseMessage);
                  authInvocationMsgRef =  CFHTTPMessageCreateRequest(NULL, CFSTR("POST"), theURL, kCFHTTPVersion1_1);
                  CFRelease(theURL);
                  
                  // Fetch the account name from the prefs file, and the password from the keychain
                  NSString *accountName = [[[NSUserDefaultsController sharedUserDefaultsController] values] valueForKey:kWebServicesSDUsernamePrefStr];
				  if (accountName == nil)
				  {
					NSArray *paths = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES);
					NSString *basePath = ([paths count] > 0) ? [paths objectAtIndex:0] : NSTemporaryDirectory();
					NSString *path = [NSString stringWithFormat:@"%@/Preferences/org.awkward.iontv.plist", basePath];
					NSData *plistData;
					NSString *error;
					NSPropertyListFormat format;
					id plist;
					plistData = [NSData dataWithContentsOfFile:path];
					 
					plist = [NSPropertyListSerialization propertyListFromData:plistData
                                mutabilityOption:NSPropertyListImmutable
                                format:&format
                                errorDescription:&error];
					accountName = [plist valueForKey:kWebServicesSDUsernamePrefStr];
					if (accountName == nil)
					{
						NSLog(@"No SchedulesDirect username in the application prefs !");
						return nil;
					}
				  }
                  NSString *password;
                  const char *serverNameUTF8 = [kWebServicesSDHostname UTF8String];
                  const char *accountNameUTF8 = [accountName UTF8String];
                  const char *pathUTF8 = [kWebServicesSDPath UTF8String];
                  UInt32 passwordLength;
                  void *passwordData;
                  OSStatus status = SecKeychainFindInternetPassword(NULL,strlen(serverNameUTF8),serverNameUTF8, 0, NULL, strlen(accountNameUTF8), accountNameUTF8, strlen(pathUTF8), pathUTF8, 80, kSecProtocolTypeHTTP, kSecAuthenticationTypeDefault, &passwordLength, &passwordData, NULL);
                  
                  if (status == noErr)
                  {
                    password = [NSString stringWithCString:passwordData length:passwordLength];
                    SecKeychainItemFreeContent(NULL, passwordData);
                  }
                  else
                  {
                    password = @"";
                  }

                  CFHTTPMessageAddAuthentication(authInvocationMsgRef, responseMessage, (CFStringRef)accountName, (CFStringRef) password, NULL, false);
                  WSMethodInvocationSetProperty(authorizedInvocation,kWSHTTPMessage,authInvocationMsgRef);
                  [fResult autorelease];
                  fResult = NULL;
                  
                  WSClientContext context = { 0, 
                                                                          (void*) self, 
                                                                          (WSClientContextRetainCallBackProcPtr) CFRetain,
                                                                          (WSClientContextReleaseCallBackProcPtr) CFRelease, 
                                                                          (WSClientContextCopyDescriptionCallBackProcPtr) CFCopyDescription
                  };

                  CFStringRef wsGeneratedAuthMode = CFSTR("NS-WSSYNCAUTH");
                  WSMethodInvocationAddDeserializationOverride(authorizedInvocation,CFSTR("urn:TMSWebServices"),CFSTR("xtvd"),deserializationCallback,&context);
                  WSMethodInvocationScheduleWithRunLoop(authorizedInvocation, [[NSRunLoop currentRunLoop] getCFRunLoop], wsGeneratedAuthMode);

                  while (fResult == NULL)
                    [[NSRunLoop currentRunLoop] runMode:(NSString *)wsGeneratedAuthMode beforeDate:[NSDate distantFuture]];
                  
                  WSMethodInvocationUnscheduleFromRunLoop(authorizedInvocation, [[NSRunLoop currentRunLoop] getCFRunLoop], wsGeneratedAuthMode);

                  if (fResult == NULL) 
                  {
                    [self handleError:@"WSMethodInvocationInvoke failed in getResultDictionary" errorString:NULL errorDomain:kCFStreamErrorDomainMacOSStatus errorNumber:paramErr];
                  }
            
                  CFRelease(authInvocationMsgRef);
                }
                CFRelease(responseMessage);
	}
	return fResult;
}

@end; /* tvDataDelivery */

/*-
 *   Method Name:  acknowledge
 * Documentation:  <no documentation>
 */
@implementation acknowledge
- (id) resultValue
{
    return [[super getResultDictionary] objectForKey: @"downloadTimes"];    
}

- (WSMethodInvocationRef) genCreateInvocationRef
{
    NSString *endpointURL = [NSString stringWithFormat:@"http://%@%@", kWebServicesSDHostname,kWebServicesSDPath];
    return [self createInvocationRef    
               /*endpoint*/: endpointURL //@"http://webservices.schedulesdirect.tmsdatadirect.com/schedulesdirect/tvlistings/xtvdService"            
                 methodName: @"acknowledge"            
                 protocol: (NSString*) kWSSOAP2001Protocol            
                      style: (NSString*) kWSSOAPStyleRPC            
                 soapAction: @"urn:TMSWebServices:xtvdWebService#acknowledge"            
            methodNamespace: @"urn:TMSWebServices"            
        ];        
}

@end; /* acknowledge */


/*-
 *   Method Name:  download
 * Documentation:  <no documentation>
 */
@implementation download
- (void) setParameters:(CFTypeRef /* Complex type urn:TMSWebServices|dateTime */) in_startTime in_endTime:(CFTypeRef /* Complex type urn:TMSWebServices|dateTime */) in_endTime
{
    id _paramValues[] = {    
        (id)in_startTime,        
        (id)in_endTime,        
    };    
    NSString* _paramNames[] = {    
        @"startTime",        
        @"endTime",        
    };    
    [super setParameters:2 values: _paramValues names: _paramNames];    
}

- (id) resultValue
{
    return [[super getResultDictionary] objectForKey: @"xtvdResponse"];    
}

- (WSMethodInvocationRef) genCreateInvocationRef
{
    NSString *endpointURL = [NSString stringWithFormat:@"http://%@%@", kWebServicesSDHostname,kWebServicesSDPath];
    WSMethodInvocationRef anInvocationRef = [self createInvocationRef    
               /*endpoint*/: endpointURL //@"http://webservices.schedulesdirect.tmsdatadirect.com/schedulesdirect/tvlistings/xtvdService"            
                 methodName: @"download"            
                 protocol: (NSString*) kWSSOAP2001Protocol            
                      style: (NSString*) kWSSOAPStyleRPC            
                 soapAction: @"urn:TMSWebServices:xtvdWebService#download"            
            methodNamespace: @"urn:TMSWebServices"            
        ];        
	WSMethodInvocationSetParameters(anInvocationRef, (CFDictionaryRef) fParams, (CFArrayRef) fParamOrder);
        return(anInvocationRef);
}

@end; /* download */



@implementation xtvdWebService

+ (id) acknowledge
{
    id result = NULL;    
    acknowledge* _invocation = [[acknowledge alloc] init];    
    result = [[_invocation resultValue] retain];    
    [_invocation release];    
    return result;    
}


+ (id) download:(CFTypeRef /* Complex type urn:TMSWebServices|dateTime */) in_startTime in_endTime:(CFTypeRef /* Complex type urn:TMSWebServices|dateTime */) in_endTime
{
    id result = NULL;    
    download* _invocation = [[download alloc] init];    
    [_invocation setParameters: in_startTime in_endTime:in_endTime];    
    result = [[_invocation resultValue] retain];    
    [_invocation release];    
    return result;    
}

@end;


@implementation xtvdDownloadThread

+ (void) performDownload:(id)downloadInfo
{
  NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
  
  NSDictionary *xtvdDownloadData = (NSDictionary*)downloadInfo;
  
  NSDictionary *downloadResult = [xtvdWebService download:[xtvdDownloadData valueForKey:@"startDateStr"] in_endTime:[xtvdDownloadData valueForKey:@"endDateStr"]];
 
  if ([[xtvdDownloadData valueForKey:@"dataRecipient"] respondsToSelector:@selector(handleDownloadData:)])
    [[xtvdDownloadData valueForKey:@"dataRecipient"] performSelectorOnMainThread:@selector(handleDownloadData:) withObject:downloadResult waitUntilDone:NO];
  [pool release];
}

@end;

/*-
 * End of WSDL document at tvDataDelivery.wsdl
 */
